/*! For license information please see neatml.js.LICENSE.txt */
!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e(require("child_process"),require("os")):"function"==typeof define&&define.amd?define(["child_process","os"],e):"object"==typeof exports?exports["NEAT-ML"]=e(require("child_process"),require("os")):t["NEAT-ML"]=e(t.child_process,t.os)}(this,(function(t,e){return n={5:t=>{"use strict";function e(t){if("string"!=typeof t)throw new TypeError("Path must be a string. Received "+JSON.stringify(t))}function n(t,e){for(var n,o="",s=0,i=-1,r=0,a=0;a<=t.length;++a){if(a<t.length)n=t.charCodeAt(a);else{if(47===n)break;n=47}if(47===n){if(i===a-1||1===r);else if(i!==a-1&&2===r){if(o.length<2||2!==s||46!==o.charCodeAt(o.length-1)||46!==o.charCodeAt(o.length-2))if(o.length>2){var h=o.lastIndexOf("/");if(h!==o.length-1){-1===h?(o="",s=0):s=(o=o.slice(0,h)).length-1-o.lastIndexOf("/"),i=a,r=0;continue}}else if(2===o.length||1===o.length){o="",s=0,i=a,r=0;continue}e&&(o.length>0?o+="/..":o="..",s=2)}else o.length>0?o+="/"+t.slice(i+1,a):o=t.slice(i+1,a),s=a-i-1;i=a,r=0}else 46===n&&-1!==r?++r:r=-1}return o}var o={resolve:function(){for(var t,o="",s=!1,i=arguments.length-1;i>=-1&&!s;i--){var r;i>=0?r=arguments[i]:(void 0===t&&(t=process.cwd()),r=t),e(r),0!==r.length&&(o=r+"/"+o,s=47===r.charCodeAt(0))}return o=n(o,!s),s?o.length>0?"/"+o:"/":o.length>0?o:"."},normalize:function(t){if(e(t),0===t.length)return".";var o=47===t.charCodeAt(0),s=47===t.charCodeAt(t.length-1);return 0!==(t=n(t,!o)).length||o||(t="."),t.length>0&&s&&(t+="/"),o?"/"+t:t},isAbsolute:function(t){return e(t),t.length>0&&47===t.charCodeAt(0)},join:function(){if(0===arguments.length)return".";for(var t,n=0;n<arguments.length;++n){var s=arguments[n];e(s),s.length>0&&(void 0===t?t=s:t+="/"+s)}return void 0===t?".":o.normalize(t)},relative:function(t,n){if(e(t),e(n),t===n)return"";if((t=o.resolve(t))===(n=o.resolve(n)))return"";for(var s=1;s<t.length&&47===t.charCodeAt(s);++s);for(var i=t.length,r=i-s,a=1;a<n.length&&47===n.charCodeAt(a);++a);for(var h=n.length-a,c=r<h?r:h,l=-1,u=0;u<=c;++u){if(u===c){if(h>c){if(47===n.charCodeAt(a+u))return n.slice(a+u+1);if(0===u)return n.slice(a+u)}else r>c&&(47===t.charCodeAt(s+u)?l=u:0===u&&(l=0));break}var p=t.charCodeAt(s+u);if(p!==n.charCodeAt(a+u))break;47===p&&(l=u)}var f="";for(u=s+l+1;u<=i;++u)u!==i&&47!==t.charCodeAt(u)||(0===f.length?f+="..":f+="/..");return f.length>0?f+n.slice(a+l):(a+=l,47===n.charCodeAt(a)&&++a,n.slice(a))},_makeLong:function(t){return t},dirname:function(t){if(e(t),0===t.length)return".";for(var n=t.charCodeAt(0),o=47===n,s=-1,i=!0,r=t.length-1;r>=1;--r)if(47===(n=t.charCodeAt(r))){if(!i){s=r;break}}else i=!1;return-1===s?o?"/":".":o&&1===s?"//":t.slice(0,s)},basename:function(t,n){if(void 0!==n&&"string"!=typeof n)throw new TypeError('"ext" argument must be a string');e(t);var o,s=0,i=-1,r=!0;if(void 0!==n&&n.length>0&&n.length<=t.length){if(n.length===t.length&&n===t)return"";var a=n.length-1,h=-1;for(o=t.length-1;o>=0;--o){var c=t.charCodeAt(o);if(47===c){if(!r){s=o+1;break}}else-1===h&&(r=!1,h=o+1),a>=0&&(c===n.charCodeAt(a)?-1==--a&&(i=o):(a=-1,i=h))}return s===i?i=h:-1===i&&(i=t.length),t.slice(s,i)}for(o=t.length-1;o>=0;--o)if(47===t.charCodeAt(o)){if(!r){s=o+1;break}}else-1===i&&(r=!1,i=o+1);return-1===i?"":t.slice(s,i)},extname:function(t){e(t);for(var n=-1,o=0,s=-1,i=!0,r=0,a=t.length-1;a>=0;--a){var h=t.charCodeAt(a);if(47!==h)-1===s&&(i=!1,s=a+1),46===h?-1===n?n=a:1!==r&&(r=1):-1!==n&&(r=-1);else if(!i){o=a+1;break}}return-1===n||-1===s||0===r||1===r&&n===s-1&&n===o+1?"":t.slice(n,s)},format:function(t){if(null===t||"object"!=typeof t)throw new TypeError('The "pathObject" argument must be of type Object. Received type '+typeof t);return function(t,e){var n=e.dir||e.root,o=e.base||(e.name||"")+(e.ext||"");return n?n===e.root?n+o:n+"/"+o:o}(0,t)},parse:function(t){e(t);var n={root:"",dir:"",base:"",ext:"",name:""};if(0===t.length)return n;var o,s=t.charCodeAt(0),i=47===s;i?(n.root="/",o=1):o=0;for(var r=-1,a=0,h=-1,c=!0,l=t.length-1,u=0;l>=o;--l)if(47!==(s=t.charCodeAt(l)))-1===h&&(c=!1,h=l+1),46===s?-1===r?r=l:1!==u&&(u=1):-1!==r&&(u=-1);else if(!c){a=l+1;break}return-1===r||-1===h||0===u||1===u&&r===h-1&&r===a+1?-1!==h&&(n.base=n.name=0===a&&i?t.slice(1,h):t.slice(a,h)):(0===a&&i?(n.name=t.slice(1,r),n.base=t.slice(1,h)):(n.name=t.slice(a,r),n.base=t.slice(a,h)),n.ext=t.slice(r,h)),a>0?n.dir=t.slice(0,a-1):i&&(n.dir="/"),n},sep:"/",delimiter:":",win32:null,posix:null};o.posix=o,t.exports=o},171:(t,e,n)=>{const o=n(313),s=n(363),i=n(73),r=n(490),a=n(568),h={Construct:t=>{let e,n=new s(0,0),o=[];for(e=0;e<t.length;e++){let n;if(t[e]instanceof i)for(n=0;n<t[e].nodes.length;n++)o.push(t[e].nodes[n]);else if(t[e]instanceof r)for(n=0;n<t[e].nodes.length;n++)for(let s=0;s<t[e].nodes[n].nodes.length;s++)o.push(t[e].nodes[n].nodes[s]);else t[e]instanceof a&&o.push(t[e])}const h=[],c=[];for(e=o.length-1;e>=0;e--)"output"===o[e].type||o[e].connections.out.length+o[e].connections.gated.length===0?(o[e].type="output",n.output++,c.push(o[e]),o.splice(e,1)):"input"!==o[e].type&&o[e].connections.in.length||(o[e].type="input",n.input++,h.push(o[e]),o.splice(e,1));if(o=h.concat(o).concat(c),0===n.input||0===n.output)throw new Error("Given nodes have no clear input/output node!");for(e=0;e<o.length;e++){let t;for(t=0;t<o[e].connections.out.length;t++)n.connections.push(o[e].connections.out[t]);for(t=0;t<o[e].connections.gated.length;t++)n.gates.push(o[e].connections.gated[t]);0!==o[e].connections.self.weight&&n.selfConns.push(o[e].connections.self)}return n.nodes=o,n},Perceptron:function(){let t=Array.prototype.slice.call(arguments);if(t.length<3)throw new Error("You have to specify at least 3 layers");const e=[];e.push(new i(t[0]));for(let n=1;n<t.length;n++){let s=t[n];s=new i(s),e.push(s),e[n-1].connect(e[n],o.connection.ALL_TO_ALL)}return h.Construct(e)},Random:(t,e,n,i)=>{let r,a=(i=i||{}).connections||2*e,h=i.backconnections||0,c=i.selfconnections||0,l=i.gates||0,u=new s(t,n);for(r=0;r<e;r++)u.mutate(o.mutation.ADD_NODE);for(r=0;r<a-e;r++)u.mutate(o.mutation.ADD_CONN);for(r=0;r<h;r++)u.mutate(o.mutation.ADD_BACK_CONN);for(r=0;r<c;r++)u.mutate(o.mutation.ADD_SELF_CONN);for(r=0;r<l;r++)u.mutate(o.mutation.ADD_GATE);return u},LSTM:function(){let t=Array.prototype.slice.call(arguments);if(t.length<3)throw new Error("You have to specify at least 3 layers");let e,n=t.pop();"number"==typeof n?(e=new i(n),n={}):e=new i(t.pop()),e.set({type:"output"});let s={};s.memoryToMemory=n.memoryToMemory||!1,s.outputToMemory=n.outputToMemory||!1,s.outputToGates=n.outputToGates||!1,s.inputToOutput=void 0===n.inputToOutput||n.inputToOutput,s.inputToDeep=void 0===n.inputToDeep||n.inputToDeep;let r=new i(t.shift());r.set({type:"input"});let a=t;const c=[];c.push(r);let l=r;for(let t=0;t<a.length;t++){let n=a[t],h=new i(n),u=new i(n),p=new i(n),f=new i(n),g=t===a.length-1?e:new i(n);h.set({bias:1}),u.set({bias:1}),f.set({bias:1});let d=l.connect(p,o.connection.ALL_TO_ALL);l.connect(h,o.connection.ALL_TO_ALL),l.connect(f,o.connection.ALL_TO_ALL),l.connect(u,o.connection.ALL_TO_ALL),p.connect(h,o.connection.ALL_TO_ALL),p.connect(u,o.connection.ALL_TO_ALL),p.connect(f,o.connection.ALL_TO_ALL);let m=p.connect(p,o.connection.ONE_TO_ONE),w=p.connect(g,o.connection.ALL_TO_ALL);if(h.gate(d,o.gating.INPUT),u.gate(m,o.gating.SELF),f.gate(w,o.gating.OUTPUT),s.inputToDeep&&t>0){let t=r.connect(p,o.connection.ALL_TO_ALL);h.gate(t,o.gating.INPUT)}if(s.memoryToMemory){let t=p.connect(p,o.connection.ALL_TO_ELSE);h.gate(t,o.gating.INPUT)}if(s.outputToMemory){let t=e.connect(p,o.connection.ALL_TO_ALL);h.gate(t,o.gating.INPUT)}s.outputToGates&&(e.connect(h,o.connection.ALL_TO_ALL),e.connect(u,o.connection.ALL_TO_ALL),e.connect(f,o.connection.ALL_TO_ALL)),c.push(h),c.push(u),c.push(p),c.push(f),t!==a.length-1&&c.push(g),l=g}return s.inputToOutput&&r.connect(e,o.connection.ALL_TO_ALL),c.push(e),h.Construct(c)},GRU:function(){let t=Array.prototype.slice.call(arguments);if(t.length<3)throw new Error("not enough layers (minimum 3) !!");let e=new i(t.shift()),n=new i(t.pop()),o=t;const s=[];s.push(e);let a=e;for(let t=0;t<o.length;t++){let e=r.GRU(o[t]);a.connect(e),a=e,s.push(e)}return a.connect(n),s.push(n),h.Construct(s)},Hopfield:t=>{let e=new i(t),n=new i(t);return e.connect(n,o.connection.ALL_TO_ALL),e.set({type:"input"}),n.set({squash:o.activation.STEP,type:"output"}),h.Construct([e,n])},NARX:(t,e,n,s,i)=>{Array.isArray(e)||(e=[e]);const a=[];let c=r.Dense(t),l=r.Memory(t,s);const u=[];let p=r.Dense(n),f=r.Memory(n,i);a.push(c),a.push(f);for(let t=0;t<e.length;t++){let n=r.Dense(e[t]);u.push(n),a.push(n),void 0!==u[t-1]&&u[t-1].connect(n,o.connection.ALL_TO_ALL)}return a.push(l),a.push(p),c.connect(u[0],o.connection.ALL_TO_ALL),c.connect(l,o.connection.ONE_TO_ONE,1),l.connect(u[0],o.connection.ALL_TO_ALL),u[u.length-1].connect(p,o.connection.ALL_TO_ALL),p.connect(f,o.connection.ONE_TO_ONE,1),f.connect(u[0],o.connection.ALL_TO_ALL),c.set({type:"input"}),p.set({type:"output"}),h.Construct(a)}};t.exports=h},722:t=>{t.exports=class{constructor(t,e,n){this.from=t,this.to=e,this.gain=1,this.weight=void 0===n?.2*Math.random()-.1:n,this.gater=null,this.elegibility=0,this.previousDeltaWeight=0,this.totalDeltaWeight=0,this.xtrace={nodes:[],values:[]}}toJSON(){return{weight:this.weight}}static innovationID(t,e){return.5*(t+e)*(t+e+1)+e}}},73:(t,e,n)=>{const o=n(313),s=n(182),i=n(490),r=n(568);class a{constructor(t){this.nodes=[],this.connections={in:[],out:[],self:[]};for(let e=0;e<t;e++)this.nodes.push(new r)}activate(t){const e=[];if(void 0!==t&&t.length!==this.nodes.length)throw new Error("Array with values should be same as the amount of nodes!");for(let n=0;n<this.nodes.length;n++){let o;o=void 0===t?this.nodes[n].activate():this.nodes[n].activate(t[n]),e.push(o)}return e}propagate(t,e,n){if(void 0!==n&&n.length!==this.nodes.length)throw new Error("Array with values should be same as the amount of nodes!");for(let o=this.nodes.length-1;o>=0;o--)void 0===n?this.nodes[o].propagate(t,e,!0):this.nodes[o].propagate(t,e,!0,n[o])}connect(t,e,n){let h,c,l=[];if(t instanceof a){if(void 0===e&&(this!==t?(s.warnings&&console.warn("No group connection specified, using ALL_TO_ALL"),e=o.connection.ALL_TO_ALL):(s.warnings&&console.warn("No group connection specified, using ONE_TO_ONE"),e=o.connection.ONE_TO_ONE)),e===o.connection.ALL_TO_ALL||e===o.connection.ALL_TO_ELSE)for(h=0;h<this.nodes.length;h++)for(c=0;c<t.nodes.length;c++){if(e===o.connection.ALL_TO_ELSE&&this.nodes[h]===t.nodes[c])continue;let s=this.nodes[h].connect(t.nodes[c],n);this.connections.out.push(s[0]),t.connections.in.push(s[0]),l.push(s[0])}else if(e===o.connection.ONE_TO_ONE){if(this.nodes.length!==t.nodes.length)throw new Error("From and To group must be the same size!");for(h=0;h<this.nodes.length;h++){let e=this.nodes[h].connect(t.nodes[h],n);this.connections.self.push(e[0]),l.push(e[0])}}}else if(t instanceof i)l=t.input(this,e,n);else if(t instanceof r)for(h=0;h<this.nodes.length;h++){let e=this.nodes[h].connect(t,n);this.connections.out.push(e[0]),l.push(e[0])}return l}gate(t,e){if(void 0===e)throw new Error("Please specify Gating.INPUT, Gating.OUTPUT");Array.isArray(t)||(t=[t]);const n=[],s=[];let i,r;for(i=0;i<t.length;i++){let e=t[i];n.includes(e.from)||n.push(e.from),s.includes(e.to)||s.push(e.to)}switch(e){case o.gating.INPUT:for(i=0;i<s.length;i++){let e=s[i],n=this.nodes[i%this.nodes.length];for(r=0;r<e.connections.in.length;r++){let o=e.connections.in[r];t.includes(o)&&n.gate(o)}}break;case o.gating.OUTPUT:for(i=0;i<n.length;i++){let e=n[i],o=this.nodes[i%this.nodes.length];for(r=0;r<e.connections.out.length;r++){let n=e.connections.out[r];t.includes(n)&&o.gate(n)}}break;case o.gating.SELF:for(i=0;i<n.length;i++){let e=n[i],o=this.nodes[i%this.nodes.length];t.includes(e.connections.self)&&o.gate(e.connections.self)}}}set(t){for(let e=0;e<this.nodes.length;e++)void 0!==t.bias&&(this.nodes[e].bias=t.bias),this.nodes[e].squash=t.squash||this.nodes[e].squash,this.nodes[e].type=t.type||this.nodes[e].type}disconnect(t,e){let n,o,s;if(e=e||!1,t instanceof a)for(n=0;n<this.nodes.length;n++)for(o=0;o<t.nodes.length;o++){for(this.nodes[n].disconnect(t.nodes[o],e),s=this.connections.out.length-1;s>=0;s--){let e=this.connections.out[s];if(e.from===this.nodes[n]&&e.to===t.nodes[o]){this.connections.out.splice(s,1);break}}if(e)for(s=this.connections.in.length-1;s>=0;s--){let e=this.connections.in[s];if(e.from===t.nodes[o]&&e.to===this.nodes[n]){this.connections.in.splice(s,1);break}}}else if(t instanceof r)for(n=0;n<this.nodes.length;n++){for(this.nodes[n].disconnect(t,e),o=this.connections.out.length-1;o>=0;o--){let e=this.connections.out[o];if(e.from===this.nodes[n]&&e.to===t){this.connections.out.splice(o,1);break}}if(e)for(o=this.connections.in.length-1;o>=0;o--){let e=this.connections.in[o];if(e.from===t&&e.to===this.nodes[n]){this.connections.in.splice(o,1);break}}}}clear(){for(let t=0;t<this.nodes.length;t++)this.nodes[t].clear()}}t.exports=a},490:(t,e,n)=>{const o=n(313),s=n(73),i=n(568);class r{constructor(){this.output=null,this.nodes=[],this.connections={in:[],out:[],self:[]}}activate(t){const e=[];if(void 0!==t&&t.length!==this.nodes.length)throw new Error("Array with values should be same as the amount of nodes!");for(let n=0;n<this.nodes.length;n++){let o;o=void 0===t?this.nodes[n].activate():this.nodes[n].activate(t[n]),e.push(o)}return e}propagate(t,e,n){if(void 0!==n&&n.length!==this.nodes.length)throw new Error("Array with values should be same as the amount of nodes!");for(let o=this.nodes.length-1;o>=0;o--)void 0===n?this.nodes[o].propagate(t,e,!0):this.nodes[o].propagate(t,e,!0,n[o])}connect(t,e,n){let o;return t instanceof s||t instanceof i?o=this.output.connect(t,e,n):t instanceof r&&(o=t.input(this,e,n)),o}gate(t,e){this.output.gate(t,e)}set(t){for(let e=0;e<this.nodes.length;e++){let n=this.nodes[e];n instanceof i?(void 0!==t.bias&&(n.bias=t.bias),n.squash=t.squash||n.squash,n.type=t.type||n.type):n instanceof s&&n.set(t)}}disconnect(t,e){let n,o,r;if(e=e||!1,t instanceof s)for(n=0;n<this.nodes.length;n++)for(o=0;o<t.nodes.length;o++){for(this.nodes[n].disconnect(t.nodes[o],e),r=this.connections.out.length-1;r>=0;r--){let e=this.connections.out[r];if(e.from===this.nodes[n]&&e.to===t.nodes[o]){this.connections.out.splice(r,1);break}}if(e)for(r=this.connections.in.length-1;r>=0;r--){let e=this.connections.in[r];if(e.from===t.nodes[o]&&e.to===this.nodes[n]){this.connections.in.splice(r,1);break}}}else if(t instanceof i)for(n=0;n<this.nodes.length;n++){for(this.nodes[n].disconnect(t,e),o=this.connections.out.length-1;o>=0;o--){let e=this.connections.out[o];if(e.from===this.nodes[n]&&e.to===t){this.connections.out.splice(o,1);break}}if(e)for(r=this.connections.in.length-1;r>=0;r--){let e=this.connections.in[r];if(e.from===t&&e.to===this.nodes[n]){this.connections.in.splice(r,1);break}}}}clear(){for(let t=0;t<this.nodes.length;t++)this.nodes[t].clear()}static Dense(t){let e=new r,n=new s(t);return e.nodes.push(n),e.output=n,e.input=function(t,e,s){return t instanceof r&&(t=t.output),e=e||o.connection.ALL_TO_ALL,t.connect(n,e,s)},e}static LSTM(t){let e=new r,n=new s(t),i=new s(t),a=new s(t),h=new s(t),c=new s(t);n.set({bias:1}),i.set({bias:1}),h.set({bias:1}),a.connect(n,o.connection.ALL_TO_ALL),a.connect(i,o.connection.ALL_TO_ALL),a.connect(h,o.connection.ALL_TO_ALL);let l=a.connect(a,o.connection.ONE_TO_ONE),u=a.connect(c,o.connection.ALL_TO_ALL);return i.gate(l,o.gating.SELF),h.gate(u,o.gating.OUTPUT),e.nodes=[n,i,a,h,c],e.output=c,e.input=function(t,e,s){t instanceof r&&(t=t.output),e=e||o.connection.ALL_TO_ALL;let c=[],l=t.connect(a,e,s);return c=c.concat(l),c=c.concat(t.connect(n,e,s)),c=c.concat(t.connect(h,e,s)),c=c.concat(t.connect(i,e,s)),n.gate(l,o.gating.INPUT),c},e}static GRU(t){let e=new this,n=new s(t),i=new s(t),a=new s(t),h=new s(t),c=new s(t),l=new s(t);l.set({bias:0,squash:o.activation.IDENTITY,type:"constant"}),h.set({squash:o.activation.TANH}),i.set({bias:0,squash:o.activation.INVERSE,type:"constant"}),n.set({bias:1}),a.set({bias:0}),l.connect(n,o.connection.ALL_TO_ALL),n.connect(i,o.connection.ONE_TO_ONE,1),l.connect(a,o.connection.ALL_TO_ALL);let u=l.connect(h,o.connection.ALL_TO_ALL);a.gate(u,o.gating.OUTPUT);let p=l.connect(c,o.connection.ALL_TO_ALL),f=h.connect(c,o.connection.ALL_TO_ALL);return n.gate(p,o.gating.OUTPUT),i.gate(f,o.gating.OUTPUT),c.connect(l,o.connection.ONE_TO_ONE,1),e.nodes=[n,i,a,h,c,l],e.output=c,e.input=function(t,e,s){t instanceof r&&(t=t.output),e=e||o.connection.ALL_TO_ALL;let i=[];return i=i.concat(t.connect(n,e,s)),i=i.concat(t.connect(a,e,s)),i=i.concat(t.connect(h,e,s)),i},e}static Memory(t,e){let n,i=new r,a=null;for(n=0;n<e;n++){let e=new s(t);e.set({squash:o.activation.IDENTITY,bias:0,type:"constant"}),null!=a&&a.connect(e,o.connection.ONE_TO_ONE,1),i.nodes.push(e),a=e}for(i.nodes.reverse(),n=0;n<i.nodes.length;n++)i.nodes[n].nodes.reverse();let h=new s(0);for(const t in i.nodes)h.nodes=h.nodes.concat(i.nodes[t].nodes);return i.output=h,i.input=function(t,e,n){if(t instanceof r&&(t=t.output),e=e||o.connection.ALL_TO_ALL,t.nodes.length!==i.nodes[i.nodes.length-1].nodes.length)throw new Error("Previous layer size must be same as memory size");return t.connect(i.nodes[i.nodes.length-1],o.connection.ONE_TO_ONE,1)},i}}t.exports=r},363:(t,e,n)=>{const o=n(182),s=n(313),i=n(607),r=n(738),a=n(568),h=n(722);let c=s.mutation;class l{constructor(t,e){if(void 0===t||void 0===e)throw new Error("No input or output size given");this.input=t,this.output=e,this.nodes=[],this.connections=[],this.gates=[],this.selfConns=[],this.dropout=0;for(let t=0;t<this.input+this.output;t++)this.nodes.push(new a(t<this.input?"input":"output"));for(let t=0;t<this.input;t++)for(let e=this.input;e<this.output+this.input;e++){let n=Math.random()*this.input*Math.sqrt(2/this.input);this.connect(this.nodes[t],this.nodes[e],n)}}activate(t,e){const n=[];for(let o=0;o<this.nodes.length;o++)if("input"===this.nodes[o].type)this.nodes[o].activate(t[o]);else if("output"===this.nodes[o].type){let t=this.nodes[o].activate();n.push(t)}else e&&(this.nodes[o].mask=Math.random()<this.dropout?0:1),this.nodes[o].activate();return n}noTraceActivate(t){const e=[];for(let n=0;n<this.nodes.length;n++)if("input"===this.nodes[n].type)this.nodes[n].noTraceActivate(t[n]);else if("output"===this.nodes[n].type){let t=this.nodes[n].noTraceActivate();e.push(t)}else this.nodes[n].noTraceActivate();return e}propagate(t,e,n,o){if(void 0===o||o.length!==this.output)throw new Error("Output target length should match network output length");let s=o.length;for(let i=this.nodes.length-1;i>=this.nodes.length-this.output;i--)this.nodes[i].propagate(t,e,n,o[--s]);for(let o=this.nodes.length-this.output-1;o>=this.input;o--)this.nodes[o].propagate(t,e,n)}clear(){for(let t=0;t<this.nodes.length;t++)this.nodes[t].clear()}connect(t,e,n){const o=t.connect(e,n);for(let n=0;n<o.length;n++){let s=o[n];t!==e?this.connections.push(s):this.selfConns.push(s)}return o}disconnect(t,e){let n=t===e?this.selfConns:this.connections;for(let o=0;o<n.length;o++){let s=n[o];if(s.from===t&&s.to===e){null!==s.gater&&this.ungate(s),n.splice(o,1);break}}t.disconnect(e)}gate(t,e){if(-1===this.nodes.indexOf(t))throw new Error("This node is not part of the network!");null==e.gater?(t.gate(e),this.gates.push(e)):o.warnings&&console.warn("This connection is already gated!")}ungate(t){let e=this.gates.indexOf(t);if(-1===e)throw new Error("This connection is not gated!");this.gates.splice(e,1),t.gater.ungate(t)}remove(t){let e=this.nodes.indexOf(t);if(-1===e)throw new Error("This node does not exist in the network!");const n=[];this.disconnect(t,t);const o=[];for(let e=t.connections.in.length-1;e>=0;e--){let s=t.connections.in[e];c.SUB_NODE.keep_gates&&null!==s.gater&&s.gater!==t&&n.push(s.gater),o.push(s.from),this.disconnect(s.from,t)}const s=[];for(let e=t.connections.out.length-1;e>=0;e--){let o=t.connections.out[e];c.SUB_NODE.keep_gates&&null!==o.gater&&o.gater!==t&&n.push(o.gater),s.push(o.to),this.disconnect(t,o.to)}const i=[];for(let t=0;t<o.length;t++){let e=o[t];for(let t=0;t<s.length;t++){let n=s[t];if(!e.isProjectingTo(n)){let t=this.connect(e,n);i.push(t[0])}}}for(let t=0;t<n.length&&0!==i.length;t++){let e=n[t],o=Math.floor(Math.random()*i.length);this.gate(e,i[o]),i.splice(o,1)}for(let e=t.connections.gated.length-1;e>=0;e--){let n=t.connections.gated[e];this.ungate(n)}this.disconnect(t,t),this.nodes.splice(e,1)}mutate(t){if(void 0===t)throw new Error("No (correct) mutate method given!");let e,n;switch(t){case c.ADD_NODE:{let t=this.connections[Math.floor(Math.random()*this.connections.length)],e=t.gater;this.disconnect(t.from,t.to);let n=this.nodes.indexOf(t.to),o=new a("hidden");o.mutate(c.MOD_ACTIVATION);let s=Math.min(n,this.nodes.length-this.output);this.nodes.splice(s,0,o);let i=this.connect(t.from,o)[0],r=this.connect(o,t.to)[0];null!=e&&this.gate(e,Math.random()>=.5?i:r);break}case c.SUB_NODE:{if(this.nodes.length===this.input+this.output){o.warnings&&console.warn("No more nodes left to remove!");break}let t=Math.floor(Math.random()*(this.nodes.length-this.output-this.input)+this.input);this.remove(this.nodes[t]);break}case c.ADD_CONN:{const t=[];for(e=0;e<this.nodes.length-this.output;e++){let o=this.nodes[e];for(n=Math.max(e+1,this.input);n<this.nodes.length;n++){let e=this.nodes[n];o.isProjectingTo(e)||t.push([o,e])}}if(0===t.length){o.warnings&&console.warn("No more connections to be made!");break}let s=t[Math.floor(Math.random()*t.length)];this.connect(s[0],s[1]);break}case c.SUB_CONN:{const t=[];for(e=0;e<this.connections.length;e++){let n=this.connections[e];n.from.connections.out.length>1&&n.to.connections.in.length>1&&this.nodes.indexOf(n.to)>this.nodes.indexOf(n.from)&&t.push(n)}if(0===t.length){o.warnings&&console.warn("No connections to remove!");break}let n=t[Math.floor(Math.random()*t.length)];this.disconnect(n.from,n.to);break}case c.MOD_WEIGHT:{let e=this.connections.concat(this.selfConns),n=e[Math.floor(Math.random()*e.length)],o=Math.random()*(t.max-t.min)+t.min;n.weight+=o;break}case c.MOD_BIAS:{let e=Math.floor(Math.random()*(this.nodes.length-this.input)+this.input);this.nodes[e].mutate(t);break}case c.MOD_ACTIVATION:{if(!t.mutateOutput&&this.input+this.output===this.nodes.length){o.warnings&&console.warn("No nodes that allow mutation of activation function");break}let e=Math.floor(Math.random()*(this.nodes.length-(t.mutateOutput?0:this.output)-this.input)+this.input);this.nodes[e].mutate(t);break}case c.ADD_SELF_CONN:{let t=[];for(e=this.input;e<this.nodes.length;e++){let n=this.nodes[e];0===n.connections.self.weight&&t.push(n)}if(0===t.length){o.warnings&&console.warn("No more self-connections to add!");break}let n=t[Math.floor(Math.random()*t.length)];this.connect(n,n);break}case c.SUB_SELF_CONN:{if(0===this.selfConns.length){o.warnings&&console.warn("No more self-connections to remove!");break}let t=this.selfConns[Math.floor(Math.random()*this.selfConns.length)];this.disconnect(t.from,t.to);break}case c.ADD_GATE:{let t=this.connections.concat(this.selfConns),n=[];for(e=0;e<t.length;e++){let o=t[e];null===o.gater&&n.push(o)}if(0===n.length){o.warnings&&console.warn("No more connections to gate!");break}let s=Math.floor(Math.random()*(this.nodes.length-this.input)+this.input),i=this.nodes[s],r=n[Math.floor(Math.random()*n.length)];this.gate(i,r);break}case c.SUB_GATE:{if(0===this.gates.length){o.warnings&&console.warn("No more connections to ungate!");break}let t=Math.floor(Math.random()*this.gates.length),e=this.gates[t];this.ungate(e);break}case c.ADD_BACK_CONN:{let t=[];for(e=this.input;e<this.nodes.length;e++){let o=this.nodes[e];for(n=this.input;n<e;n++){let e=this.nodes[n];o.isProjectingTo(e)||t.push([o,e])}}if(0===t.length){o.warnings&&console.warn("No more connections to be made!");break}let s=t[Math.floor(Math.random()*t.length)];this.connect(s[0],s[1]);break}case c.SUB_BACK_CONN:{let t=[];for(e=0;e<this.connections.length;e++){let n=this.connections[e];n.from.connections.out.length>1&&n.to.connections.in.length>1&&this.nodes.indexOf(n.from)>this.nodes.indexOf(n.to)&&t.push(n)}if(0===t.length){o.warnings&&console.warn("No connections to remove!");break}let n=t[Math.floor(Math.random()*t.length)];this.disconnect(n.from,n.to);break}case c.SWAP_NODES:{if(t.mutateOutput&&this.nodes.length-this.input<2||!t.mutateOutput&&this.nodes.length-this.input-this.output<2){o.warnings&&console.warn("No nodes that allow swapping of bias and activation function");break}let e=Math.floor(Math.random()*(this.nodes.length-(t.mutateOutput?0:this.output)-this.input)+this.input),n=this.nodes[e];e=Math.floor(Math.random()*(this.nodes.length-(t.mutateOutput?0:this.output)-this.input)+this.input);let s=this.nodes[e],i=n.bias,r=n.squash;n.bias=s.bias,n.squash=s.squash,s.bias=i,s.squash=r;break}}}train(t,e){if(t[0].input.length!==this.input||t[0].output.length!==this.output)throw new Error("Dataset input/output size should be same as network input/output size!");void 0===(e=e||{}).rate&&o.warnings&&console.warn("Using default learning rate, please define a rate!"),void 0===e.iterations&&o.warnings&&console.warn("No target iterations given, running until error is reached!");let n,i,r=e.error||.05,a=e.cost||s.cost.MSE,h=e.rate||.3,c=e.dropout||0,l=e.momentum||0,u=e.batchSize||1,p=e.ratePolicy||s.rate.FIXED(),f=Date.now();if(u>t.length)throw new Error("Batch size must be smaller or equal to dataset length!");if(void 0===e.iterations&&void 0===e.error)throw new Error("At least one of the following options must be specified: error, iterations");if(void 0===e.error?r=-1:void 0===e.iterations&&(e.iterations=0),this.dropout=c,e.crossValidate){let o=Math.ceil((1-e.crossValidate.testSize)*t.length);n=t.slice(0,o),i=t.slice(o)}let g,d,m,w=h,O=0,A=1;for(;A>r&&(0===e.iterations||O<e.iterations)&&!(e.crossValidate&&A<=e.crossValidate.testError);){if(O++,w=p(h,O),e.crossValidate?(this.#trainSet(n,u,w,l,a),e.clear&&this.clear(),A=this.test(i,a).error,e.clear&&this.clear()):(A=this.#trainSet(t,u,w,l,a),e.clear&&this.clear()),e.shuffle)for(g=t.length;g;d=Math.floor(Math.random()*g),m=t[--g],t[g]=t[d],t[d]=m);e.log&&O%e.log==0&&console.log("iteration",O,"error",A,"rate",w),e.schedule&&O%e.schedule.iterations==0&&e.schedule.function({error:A,iteration:O})}if(e.clear&&this.clear(),c)for(g=0;g<this.nodes.length;g++)"hidden"!==this.nodes[g].type&&"constant"!==this.nodes[g].type||(this.nodes[g].mask=1-this.dropout);return{error:A,iterations:O,time:Date.now()-f}}#trainSet(t,e,n,o,s){let i=0;for(let r=0;r<t.length;r++){let a=t[r].input,h=t[r].output,c=!((r+1)%e!=0&&r+1!==t.length),l=this.activate(a,!0);this.propagate(n,o,c,h),i+=s(h,l)}return i/t.length}test(t,e=s.cost.MSE){let n;if(this.dropout)for(n=0;n<this.nodes.length;n++)"hidden"!==this.nodes[n].type&&"constant"!==this.nodes[n].type||(this.nodes[n].mask=1-this.dropout);let o=0,i=Date.now();for(n=0;n<t.length;n++){let s=t[n].input;o+=e(t[n].output,this.noTraceActivate(s))}return o/=t.length,{error:o,time:Date.now()-i}}graph(t,e){let n,o=0,s=0,i={nodes:[],links:[],constraints:[{type:"alignment",axis:"x",offsets:[]},{type:"alignment",axis:"y",offsets:[]}]};for(n=0;n<this.nodes.length;n++){let r=this.nodes[n];"input"===r.type?(1===this.input?i.constraints[0].offsets.push({node:n,offset:0}):i.constraints[0].offsets.push({node:n,offset:.8*t/(this.input-1)*o++}),i.constraints[1].offsets.push({node:n,offset:0})):"output"===r.type&&(1===this.output?i.constraints[0].offsets.push({node:n,offset:0}):i.constraints[0].offsets.push({node:n,offset:.8*t/(this.output-1)*s++}),i.constraints[1].offsets.push({node:n,offset:-.8*e})),i.nodes.push({id:n,name:"hidden"===r.type?r.squash.name:r.type.toUpperCase(),activation:r.activation,bias:r.bias})}let r=this.connections.concat(this.selfConns);for(n=0;n<r.length;n++){let t=r[n];if(null==t.gater)i.links.push({source:this.nodes.indexOf(t.from),target:this.nodes.indexOf(t.to),weight:t.weight});else{let e=i.nodes.length;i.nodes.push({id:e,activation:t.gater.activation,name:"GATE"}),i.links.push({source:this.nodes.indexOf(t.from),target:e,weight:.5*t.weight}),i.links.push({source:e,target:this.nodes.indexOf(t.to),weight:.5*t.weight}),i.links.push({source:this.nodes.indexOf(t.gater),target:e,weight:t.gater.activation,gate:!0})}}return i}toJSON(){let t,e={nodes:[],connections:[],input:this.input,output:this.output,dropout:this.dropout};for(t=0;t<this.nodes.length;t++)this.nodes[t].index=t;for(t=0;t<this.nodes.length;t++){let n=this.nodes[t],o=n.toJSON();if(o.index=t,e.nodes.push(o),0!==n.connections.self.weight){let o=n.connections.self.toJSON();o.from=t,o.to=t,o.gater=null!=n.connections.self.gater?n.connections.self.gater.index:null,e.connections.push(o)}}for(t=0;t<this.connections.length;t++){let n=this.connections[t],o=n.toJSON();o.from=n.from.index,o.to=n.to.index,o.gater=null!=n.gater?n.gater.index:null,e.connections.push(o)}return e}set(t){for(let e=0;e<this.nodes.length;e++)this.nodes[e].bias=t.bias||this.nodes[e].bias,this.nodes[e].squash=t.squash||this.nodes[e].squash}async evolve(t,e){if(t[0].input.length!==this.input||t[0].output.length!==this.output)throw new Error("Dataset input/output size should be same as network input/output size!");let o=void 0!==(e=e||{}).error?e.error:.05,a=void 0!==e.growth?e.growth:1e-4,h=e.cost||s.cost.MSE,c=e.amount||1,l=e.threads;void 0===l&&(l="undefined"==typeof window?n(87).cpus().length:navigator.hardwareConcurrency);let u,p=Date.now();if(void 0===e.iterations&&void 0===e.error)throw new Error("At least one of the following options must be specified: error, iterations");if(void 0===e.error?o=-1:void 0===e.iterations&&(e.iterations=0),1===l)u=function(e){let n=0;for(let o=0;o<c;o++)n-=e.test(t,h).error;return n-=(e.nodes.length-e.input-e.output+e.connections.length+e.gates.length)*a,n=isNaN(n)?-1/0:n,n/c};else{let n=i.serializeDataSet(t);var f=[];if("undefined"==typeof window)for(let t=0;t<l;t++)f.push(new i.workers.node.TestWorker(n,h));else for(let t=0;t<l;t++)f.push(new i.workers.browser.TestWorker(n,h));u=function(t){return new Promise(((e,n)=>{let o=t.slice(),s=0,i=function(t){if(!o.length)return void(++s===l&&e());let n=o.shift();t.evaluate(n).then((function(e){n.score=-e,n.score-=(n.nodes.length-n.input-n.output+n.connections.length+n.gates.length)*a,n.score=isNaN(parseFloat(e))?-1/0:n.score,i(t)}))};for(let t=0;t<f.length;t++)i(f[t])}))},e.fitnessPopulation=!0}e.network=this;let g,d=new r(this.input,this.output,u,e),m=-1/0,w=-1/0;for(;m<-o&&(0===e.iterations||d.generation<e.iterations);){let t=await d.evolve(),n=t.score;m=n+(t.nodes.length-t.input-t.output+t.connections.length+t.gates.length)*a,n>w&&(w=n,g=t),e.log&&d.generation%e.log==0&&console.log("iteration",d.generation,"fitness",n,"error",-m),e.schedule&&d.generation%e.schedule.iterations==0&&e.schedule.function({fitness:n,error:-m,iteration:d.generation})}if(l>1)for(let t=0;t<f.length;t++)f[t].terminate();return void 0!==g&&(this.nodes=g.nodes,this.connections=g.connections,this.selfConns=g.selfConns,this.gates=g.gates,e.clear&&this.clear()),{error:-m,iterations:d.generation,time:Date.now()-p}}standalone(){const t=[],e=[],n=[],o=[],s=[];let i;for(i=0;i<this.input;i++){let t=this.nodes[i];e.push(t.activation),n.push(t.state)}for(o.push("for(let i = 0; i < input.length; i++) A[i] = input[i];"),i=0;i<this.nodes.length;i++)this.nodes[i].index=i;for(i=this.input;i<this.nodes.length;i++){let r=this.nodes[i];e.push(r.activation),n.push(r.state);let a=t.indexOf(r.squash.name);-1===a&&(a=t.length,t.push(r.squash.name),s.push(r.squash.toString()));const h=[];for(let t=0;t<r.connections.in.length;t++){let e=r.connections.in[t],n=`A[${e.from.index}] * ${e.weight}`;null!=e.gater&&(n+=` * A[${e.gater.index}]`),h.push(n)}if(r.connections.self.weight){let t=r.connections.self,e=`S[${i}] * ${t.weight}`;null!=t.gater&&(e+=` * A[${t.gater.index}]`),h.push(e)}let c=`S[${i}] = ${h.join(" + ")} + ${r.bias};`,l=`A[${i}] = F[${a}](S[${i}])${r.mask?"":" * "+r.mask};`;o.push(c),o.push(l)}let r=[];for(i=this.nodes.length-this.output;i<this.nodes.length;i++)r.push(`A[${i}]`);r=`return [${r.join(",")}];`,o.push(r);let a="";return a+=`let F = [${s.toString()}];\r\n`,a+=`let A = [${e.toString()}];\r\n`,a+=`let S = [${n.toString()}];\r\n`,a+=`function activate(input){\r\n${o.join("\r\n")}\r\n}`,a}serialize(){const t=[],e=[],n=[],o=["LOGISTIC","TANH","IDENTITY","STEP","RELU","SOFTSIGN","SINUSOID","GAUSSIAN","BENT_IDENTITY","BIPOLAR","BIPOLAR_SIGMOID","HARD_TANH","ABSOLUTE","INVERSE","SELU"];let s;for(n.push(this.input),n.push(this.output),s=0;s<this.nodes.length;s++){let n=this.nodes[s];n.index=s,t.push(n.activation),e.push(n.state)}for(s=this.input;s<this.nodes.length;s++){let t=this.nodes[s];n.push(t.index),n.push(t.bias),n.push(o.indexOf(t.squash.name)),n.push(t.connections.self.weight),n.push(null==t.connections.self.gater?-1:t.connections.self.gater.index);for(let e=0;e<t.connections.in.length;e++){let o=t.connections.in[e];n.push(o.from.index),n.push(o.weight),n.push(null==o.gater?-1:o.gater.index)}n.push(-2)}return[t,e,n]}static fromJson=t=>{let e,n=new this(t.input,t.output);for(n.dropout=t.dropout,n.nodes=[],n.connections=[],e=0;e<t.nodes.length;e++)n.nodes.push(a.fromJSON(t.nodes[e]));for(e=0;e<t.connections.length;e++){let o=t.connections[e],s=n.connect(n.nodes[o.from],n.nodes[o.to])[0];s.weight=o.weight,null!=o.gater&&n.gate(n.nodes[o.gater],s)}return n};static merge(t,e){if(t=this.fromJSON(t.toJSON()),e=this.fromJSON(e.toJSON()),t.output!==e.input)throw new Error("Output size of network1 should be the same as the input size of network2!");let n;for(n=0;n<e.connections.length;n++){let o=e.connections[n];if("input"===o.from.type){let n=e.nodes.indexOf(o.from);o.from=t.nodes[t.nodes.length-1-n]}}for(n=e.input-1;n>=0;n--)e.nodes.splice(n,1);for(n=t.nodes.length-t.output;n<t.nodes.length;n++)t.nodes[n].type="hidden";return t.connections=t.connections.concat(e.connections),t.nodes=t.nodes.concat(e.nodes),t}static crossOver(t,e,n){if(t.input!==e.input||t.output!==e.output)throw new Error("Networks don't have the same input/output size!");let o=new l(t.input,t.output);o.connections=[],o.nodes=[];let s,i=t.score||0,r=e.score||0;if(n||i===r){let n=Math.max(t.nodes.length,e.nodes.length),o=Math.min(t.nodes.length,e.nodes.length);s=Math.floor(Math.random()*(n-o+1)+o)}else s=i>r?t.nodes.length:e.nodes.length;let c,u=t.output;for(c=0;c<t.nodes.length;c++)t.nodes[c].index=c;for(c=0;c<e.nodes.length;c++)e.nodes[c].index=c;for(c=0;c<s;c++){let n;if(c<s-u){let o=Math.random();n=o>=.5?t.nodes[c]:e.nodes[c];let s=o<.5?t.nodes[c]:e.nodes[c];void 0!==n&&"output"!==n.type||(n=s)}else n=Math.random()>=.5?t.nodes[t.nodes.length+c-s]:e.nodes[e.nodes.length+c-s];let i=new a;i.bias=n.bias,i.squash=n.squash,i.type=n.type,o.nodes.push(i)}let p={},f={};for(c=0;c<t.connections.length;c++){let e=t.connections[c],n={weight:e.weight,from:e.from.index,to:e.to.index,gater:null!=e.gater?e.gater.index:-1};p[h.innovationID(n.from,n.to)]=n}for(c=0;c<t.selfConns.length;c++){let e=t.selfConns[c],n={weight:e.weight,from:e.from.index,to:e.to.index,gater:null!=e.gater?e.gater.index:-1};p[h.innovationID(n.from,n.to)]=n}for(c=0;c<e.connections.length;c++){let t=e.connections[c],n={weight:t.weight,from:t.from.index,to:t.to.index,gater:null!=t.gater?t.gater.index:-1};f[h.innovationID(n.from,n.to)]=n}for(c=0;c<e.selfConns.length;c++){let t=e.selfConns[c],n={weight:t.weight,from:t.from.index,to:t.to.index,gater:null!=t.gater?t.gater.index:-1};f[h.innovationID(n.from,n.to)]=n}const g=[];let d=Object.keys(p),m=Object.keys(f);for(c=d.length-1;c>=0;c--)if(void 0!==f[d[c]]){let t=Math.random()>=.5?p[d[c]]:f[d[c]];g.push(t),f[d[c]]=void 0}else(i>=r||n)&&g.push(p[d[c]]);if(r>=i||n)for(c=0;c<m.length;c++)void 0!==f[m[c]]&&g.push(f[m[c]]);for(c=0;c<g.length;c++){let t=g[c];if(t.to<s&&t.from<s){let e=o.nodes[t.from],n=o.nodes[t.to],i=o.connect(e,n)[0];i.weight=t.weight,-1!==t.gater&&t.gater<s&&o.gate(o.nodes[t.gater],i)}}return o}}t.exports=l},568:(t,e,n)=>{const o=n(313),s=n(722),i=n(182);t.exports=class{constructor(t){this.bias="input"===t?0:.2*Math.random()-.1,this.squash=o.activation.LOGISTIC,this.type=t||"hidden",this.activation=0,this.state=0,this.old=0,this.mask=1,this.previousDeltaBias=0,this.totalDeltaBias=0,this.connections={in:[],out:[],gated:[],self:new s(this,this,0)},this.error={responsibility:0,projected:0,gated:0}}activate(t){if(void 0!==t)return this.activation=t,this.activation;let e;for(this.old=this.state,this.state=this.connections.self.gain*this.connections.self.weight*this.state+this.bias,e=0;e<this.connections.in.length;e++){let t=this.connections.in[e];this.state+=t.from.activation*t.weight*t.gain}this.activation=this.squash(this.state)*this.mask,this.derivative=this.squash(this.state,!0);const n=[],o=[];for(e=0;e<this.connections.gated.length;e++){let t=this.connections.gated[e],s=t.to,i=n.indexOf(s);i>-1?o[i]+=t.weight*t.from.activation:(n.push(s),o.push(t.weight*t.from.activation+(s.connections.self.gater===this?s.old:0))),t.gain=this.activation}for(e=0;e<this.connections.in.length;e++){let t=this.connections.in[e];t.elegibility=this.connections.self.gain*this.connections.self.weight*t.elegibility+t.from.activation*t.gain;for(let e=0;e<n.length;e++){let s=n[e],i=o[e],r=t.xtrace.nodes.indexOf(s);r>-1?t.xtrace.values[r]=s.connections.self.gain*s.connections.self.weight*t.xtrace.values[r]+this.derivative*t.elegibility*i:(t.xtrace.nodes.push(s),t.xtrace.values.push(this.derivative*t.elegibility*i))}}return this.activation}noTraceActivate(t){if(void 0!==t)return this.activation=t,this.activation;let e;for(this.state=this.connections.self.gain*this.connections.self.weight*this.state+this.bias,e=0;e<this.connections.in.length;e++){let t=this.connections.in[e];this.state+=t.from.activation*t.weight*t.gain}for(this.activation=this.squash(this.state),e=0;e<this.connections.gated.length;e++)this.connections.gated[e].gain=this.activation;return this.activation}propagate(t,e,n,o){e=e||0,t=t||.3;let s=0;if("output"===this.type)this.error.responsibility=this.error.projected=o-this.activation;else{let t;for(t=0;t<this.connections.out.length;t++){let e=this.connections.out[t];s+=e.to.error.responsibility*e.weight*e.gain}for(this.error.projected=this.derivative*s,s=0,t=0;t<this.connections.gated.length;t++){let e=this.connections.gated[t],n=e.to,o=n.connections.self.gater===this?n.old:0;o+=e.weight*e.from.activation,s+=n.error.responsibility*o}this.error.gated=this.derivative*s,this.error.responsibility=this.error.projected+this.error.gated}if("constant"===this.type)return;for(let o=0;o<this.connections.in.length;o++){let s=this.connections.in[o],i=this.error.projected*s.elegibility;for(let t=0;t<s.xtrace.nodes.length;t++){let e=s.xtrace.nodes[t],n=s.xtrace.values[t];i+=e.error.responsibility*n}let r=t*i*this.mask;s.totalDeltaWeight+=r,n&&(s.totalDeltaWeight+=e*s.previousDeltaWeight,s.weight+=s.totalDeltaWeight,s.previousDeltaWeight=s.totalDeltaWeight,s.totalDeltaWeight=0)}let i=t*this.error.responsibility;this.totalDeltaBias+=i,n&&(this.totalDeltaBias+=e*this.previousDeltaBias,this.bias+=this.totalDeltaBias,this.previousDeltaBias=this.totalDeltaBias,this.totalDeltaBias=0)}connect(t,e){const n=[];if(void 0!==t.bias)if(t===this)0!==this.connections.self.weight?i.warnings&&console.warn("This connection already exists!"):this.connections.self.weight=e||1,n.push(this.connections.self);else{if(this.isProjectingTo(t))throw new Error("Already projecting a connection to this node!");{let o=new s(this,t,e);t.connections.in.push(o),this.connections.out.push(o),n.push(o)}}else for(let o=0;o<t.nodes.length;o++){let i=new s(this,t.nodes[o],e);t.nodes[o].connections.in.push(i),this.connections.out.push(i),t.connections.in.push(i),n.push(i)}return n}disconnect(t,e){if(this!==t){for(let e=0;e<this.connections.out.length;e++){let n=this.connections.out[e];if(n.to===t){this.connections.out.splice(e,1);let t=n.to.connections.in.indexOf(n);n.to.connections.in.splice(t,1),null!==n.gater&&n.gater.ungate(n);break}}e&&t.disconnect(this)}else this.connections.self.weight=0}gate(t){Array.isArray(t)||(t=[t]);for(let e=0;e<t.length;e++){let n=t[e];this.connections.gated.push(n),n.gater=this}}ungate(t){Array.isArray(t)||(t=[t]);for(let e=t.length-1;e>=0;e--){let n=t[e],o=this.connections.gated.indexOf(n);this.connections.gated.splice(o,1),n.gater=null,n.gain=1}}clear(){let t;for(t=0;t<this.connections.in.length;t++){let e=this.connections.in[t];e.elegibility=0,e.xtrace={nodes:[],values:[]}}for(t=0;t<this.connections.gated.length;t++)this.connections.gated[t].gain=0;this.error.responsibility=this.error.projected=this.error.gated=0,this.old=this.state=this.activation=0}mutate(t){if(void 0===t)throw new Error("No mutate method given!");if(!(t.name in o.mutation))throw new Error("This method does not exist!");switch(t){case o.mutation.MOD_ACTIVATION:{let e=t.allowed[(t.allowed.indexOf(this.squash)+Math.floor(Math.random()*(t.allowed.length-1))+1)%t.allowed.length];this.squash=e;break}case o.mutation.MOD_BIAS:{let e=Math.random()*(t.max-t.min)+t.min;this.bias+=e;break}}}isProjectingTo(t){if(t===this&&0!==this.connections.self.weight)return!0;for(let e=0;e<this.connections.out.length;e++)if(this.connections.out[e].to===t)return!0;return!1}isProjectedBy(t){if(t===this&&0!==this.connections.self.weight)return!0;for(let e=0;e<this.connections.in.length;e++)if(this.connections.in[e].from===t)return!0;return!1}toJSON(){return{bias:this.bias,type:this.type,squash:this.squash.name,mask:this.mask}}static fromJSON(t){let e=new this;return e.bias=t.bias,e.type=t.type,e.mask=t.mask,e.squash=o.activation[t.squash],e}}},182:t=>{t.exports={warnings:!1}},361:t=>{const e={LOGISTIC:(t,e)=>{let n=1/(1+Math.exp(-t));return e?n*(1-n):n},TANH:(t,e)=>e?1-Math.pow(Math.tanh(t),2):Math.tanh(t),IDENTITY:(t,e)=>e?1:t,STEP:(t,e)=>e?0:t>0?1:0,RELU:(t,e)=>e?t>0?1:0:t>0?t:0,SOFTSIGN:(t,e)=>{let n=1+Math.abs(t);return e?t/Math.pow(n,2):t/n},SINUSOID:(t,e)=>e?Math.cos(t):Math.sin(t),GAUSSIAN:(t,e)=>{let n=Math.exp(-Math.pow(t,2));return e?-2*t*n:n},BENT_IDENTITY:(t,e)=>{let n=Math.sqrt(Math.pow(t,2)+1);return e?t/(2*n)+1:(n-1)/2+t},BIPOLAR:(t,e)=>e?0:t>0?1:-1,BIPOLAR_SIGMOID:(t,e)=>{let n=2/(1+Math.exp(-t))-1;return e?.5*(1+n)*(1-n):n},HARD_TANH:(t,e)=>e?t>-1&&t<1?1:0:Math.max(-1,Math.min(1,t)),ABSOLUTE:(t,e)=>e?t<0?-1:1:Math.abs(t),INVERSE:(t,e)=>e?-1:1-t,SELU:(t,e)=>{var n=1.6732632423543772,o=1.0507009873554805,s=t>0?t:n*Math.exp(t)-n;return e?t>0?o:(s+n)*o:s*o}};t.exports=e},97:t=>{t.exports={ALL_TO_ALL:{name:"OUTPUT"},ALL_TO_ELSE:{name:"INPUT"},ONE_TO_ONE:{name:"SELF"}}},239:t=>{const e={CROSS_ENTROPY:(t,e)=>{let n=0;for(let o=0;o<e.length;o++)n-=t[o]*Math.log(Math.max(e[o],1e-15))+(1-t[o])*Math.log(1-Math.max(e[o],1e-15));return n/e.length},MSE:(t,e)=>{let n=0;for(let o=0;o<e.length;o++)n+=Math.pow(t[o]-e[o],2);return n/e.length},BINARY:(t,e)=>{let n=0;for(let o=0;o<e.length;o++)n+=Math.round(2*t[o])!==Math.round(2*e[o]);return n},MAE:(t,e)=>{let n=0;for(let o=0;o<e.length;o++)n+=Math.abs(t[o]-e[o]);return n/e.length},MAPE:(t,e)=>{let n=0;for(let o=0;o<e.length;o++)n+=Math.abs((e[o]-t[o])/Math.max(t[o],1e-15));return n/e.length},MSLE:(t,e)=>{let n=0;for(let o=0;o<e.length;o++)n+=Math.log(Math.max(t[o],1e-15))-Math.log(Math.max(e[o],1e-15));return n},HINGE:(t,e)=>{let n=0;for(let o=0;o<e.length;o++)n+=Math.max(0,1-t[o]*e[o]);return n}};t.exports=e},104:t=>{t.exports={SINGLE_POINT:{name:"SINGLE_POINT",config:[.4]},TWO_POINT:{name:"TWO_POINT",config:[.4,.9]},UNIFORM:{name:"UNIFORM"},AVERAGE:{name:"AVERAGE"}}},293:t=>{t.exports={OUTPUT:{name:"OUTPUT"},INPUT:{name:"INPUT"},SELF:{name:"SELF"}}},313:(t,e,n)=>{const o={activation:n(361),mutation:n(719),selection:n(346),crossover:n(104),cost:n(239),gating:n(293),connection:n(97),rate:n(438)};t.exports=o},719:(t,e,n)=>{const o=n(361),s={ADD_NODE:{name:"ADD_NODE"},SUB_NODE:{name:"SUB_NODE",keep_gates:!0},ADD_CONN:{name:"ADD_CONN"},SUB_CONN:{name:"REMOVE_CONN"},MOD_WEIGHT:{name:"MOD_WEIGHT",min:-1,max:1},MOD_BIAS:{name:"MOD_BIAS",min:-1,max:1},MOD_ACTIVATION:{name:"MOD_ACTIVATION",mutateOutput:!0,allowed:[o.LOGISTIC,o.TANH,o.RELU,o.IDENTITY,o.STEP,o.SOFTSIGN,o.SINUSOID,o.GAUSSIAN,o.BENT_IDENTITY,o.BIPOLAR,o.BIPOLAR_SIGMOID,o.HARD_TANH,o.ABSOLUTE,o.INVERSE,o.SELU]},ADD_SELF_CONN:{name:"ADD_SELF_CONN"},SUB_SELF_CONN:{name:"SUB_SELF_CONN"},ADD_GATE:{name:"ADD_GATE"},SUB_GATE:{name:"SUB_GATE"},ADD_BACK_CONN:{name:"ADD_BACK_CONN"},SUB_BACK_CONN:{name:"SUB_BACK_CONN"},SWAP_NODES:{name:"SWAP_NODES",mutateOutput:!0}};s.ALL=[s.ADD_NODE,s.SUB_NODE,s.ADD_CONN,s.SUB_CONN,s.MOD_WEIGHT,s.MOD_BIAS,s.MOD_ACTIVATION,s.ADD_GATE,s.SUB_GATE,s.ADD_SELF_CONN,s.SUB_SELF_CONN,s.ADD_BACK_CONN,s.SUB_BACK_CONN,s.SWAP_NODES],s.FFW=[s.ADD_NODE,s.SUB_NODE,s.ADD_CONN,s.SUB_CONN,s.MOD_WEIGHT,s.MOD_BIAS,s.MOD_ACTIVATION,s.SWAP_NODES],t.exports=s},438:t=>{const e={FIXED:()=>(t,e)=>t,STEP:(t,e)=>(t=t||.9,e=e||100,(n,o)=>n*Math.pow(t,Math.floor(o/e))),EXP:t=>(t=t||.999,(e,n)=>e*Math.pow(t,n)),INV:(t,e)=>(t=t||.001,e=e||2,(n,o)=>n*Math.pow(1+t*o,-e))};t.exports=e},346:t=>{t.exports={FITNESS_PROPORTIONATE:{name:"FITNESS_PROPORTIONATE"},POWER:{name:"POWER",power:4},TOURNAMENT:{name:"TOURNAMENT",size:5,probability:.5}}},607:(t,e,n)=>{const o={workers:n(133),serializeDataSet:t=>{const e=[t[0].input.length,t[0].output.length];let n,o;for(n=0;n<t.length;n++){for(o=0;o<e[0];o++)e.push(t[n].input[o]);for(o=0;o<e[1];o++)e.push(t[n].output[o])}return e},activateSerializedNetwork:(t,e,n,o,s)=>{let i;for(i=0;i<o[0];i++)e[i]=t[i];for(i=2;i<o.length;i++){let t=o[i++],r=o[i++],a=o[i++],h=o[i++],c=o[i++];for(n[t]=(-1===c?1:e[c])*h*n[t]+r;-2!==o[i];)n[t]+=e[o[i++]]*o[i++]*(-1===o[i++]?1:e[o[i-1]]);e[t]=s[a](n[t])}const r=[];for(i=e.length-o[1];i<e.length;i++)r.push(e[i]);return r},deserializeDataSet:t=>{const e=[];let n,o,s=t[0]+t[1];for(n=0;n<(t.length-2)/s;n++){const i=[];for(o=2+n*s;o<2+n*s+t[0];o++)i.push(t[o]);const r=[];for(o=2+n*s+t[0];o<2+n*s+s;o++)r.push(t[o]);e.push(i),e.push(r)}return e},activations:[function(t){return 1/(1+Math.exp(-t))},function(t){return Math.tanh(t)},function(t){return t},function(t){return t>0?1:0},function(t){return t>0?t:0},function(t){return t/(1+Math.abs(t))},function(t){return Math.sin(t)},function(t){return Math.exp(-Math.pow(t,2))},function(t){return(Math.sqrt(Math.pow(t,2)+1)-1)/2+t},function(t){return t>0?1:-1},function(t){return 2/(1+Math.exp(-t))-1},function(t){return Math.max(-1,Math.min(1,t))},function(t){return Math.abs(t)},function(t){return 1-t},function(t){var e=1.6732632423543772;return 1.0507009873554805*(t>0?t:e*Math.exp(t)-e)}],testSerializedSet:function(t,e,n,s,i,r){let a=0;for(let h=0;h<t.length;h+=2){let c=o.activateSerializedNetwork(t[h],n,s,i,r);a+=e(t[h+1],c)}return a/(t.length/2)}};for(const e in o)t.exports[e]=o[e]},500:(t,e,n)=>{const o=n(607);t.exports=class{constructor(t,e){let n=new Blob([this.#createBlobString(e)]);this.url=window.URL.createObjectURL(n),this.worker=new Worker(this.url);let o={set:new Float64Array(t).buffer};this.worker.postMessage(o,[o.set])}evaluate(t){return new Promise(((e,n)=>{let o=t.serialize(),s={activations:new Float64Array(o[0]).buffer,states:new Float64Array(o[1]).buffer,conns:new Float64Array(o[2]).buffer};this.worker.onmessage=function(t){let n=new Float64Array(t.data.buffer)[0];e(n)},this.worker.postMessage(s,[s.activations,s.states,s.conns])}))}terminate(){this.worker.terminate(),window.URL.revokeObjectURL(this.url)}#createBlobString(t){return`\n      var F = [${o.activations.toString()}];\n      var cost = ${t.toString()};\n      var multi = {\n        deserializeDataSet: ${o.deserializeDataSet.toString()},\n        testSerializedSet: ${o.testSerializedSet.toString()},\n        activateSerializedNetwork: ${o.activateSerializedNetwork.toString()}\n      };\n      this.onmessage = function (e) {\n        if(typeof e.data.set === 'undefined'){\n          var A = new Float64Array(e.data.activations);\n          var S = new Float64Array(e.data.states);\n          var data = new Float64Array(e.data.conns);\n          var error = multi.testSerializedSet(set, cost, A, S, data, F);\n          var answer = { buffer: new Float64Array([error ]).buffer };\n          postMessage(answer, [answer.buffer]);\n        } else {\n          set = multi.deserializeDataSet(new Float64Array(e.data.set));\n        }\n      };`}}},50:(t,e,n)=>{const o=n(129),s=n(5);t.exports=class{constructor(t,e){this.worker=o.fork(s.join(__dirname,"/worker")),this.worker.send({set:t,cost:e.name})}evaluate(t){return new Promise(((e,n)=>{let o=t.serialize(),s={activations:o[0],states:o[1],conns:o[2]},i=this.worker;this.worker.on("message",(function t(n){i.removeListener("message",t),e(n)})),this.worker.send(s)}))}terminate(){this.worker.kill()}}},133:(t,e,n)=>{const o={node:{TestWorker:n(50)},browser:{TestWorker:n(500)}};t.exports=o},738:(t,e,n)=>{const o=n(363),s=n(313),i=n(182),r=s.selection;t.exports=class{constructor(t,e,n,o){this.input=t,this.output=e,this.fitness=n,o=o||{},this.equal=o.equal||!1,this.clear=o.clear||!1,this.popsize=o.popsize||50,this.elitism=o.elitism||0,this.provenance=o.provenance||0,this.mutationRate=o.mutationRate||.3,this.mutationAmount=o.mutationAmount||1,this.fitnessPopulation=o.fitnessPopulation||!1,this.selection=o.selection||s.selection.POWER,this.crossover=o.crossover||[s.crossover.SINGLE_POINT,s.crossover.TWO_POINT,s.crossover.UNIFORM,s.crossover.AVERAGE],this.mutation=o.mutation||s.mutation.FFW,this.template=o.network||!1,this.maxNodes=o.maxNodes||1/0,this.maxConns=o.maxConns||1/0,this.maxGates=o.maxGates||1/0,this.selectMutationMethod="function"==typeof o.mutationSelection?o.mutationSelection.bind(this):this.selectMutationMethod,this.generation=0,this.createPool(this.template)}createPool(t){this.population=[];for(let e=0;e<this.popsize;e++){let e;e=this.template?o.fromJSON(t.toJSON()):new o(this.input,this.output),e.score=void 0,this.population.push(e)}}async evolve(){void 0===this.population[this.population.length-1].score&&await this.evaluate(),this.sort();let t=o.fromJSON(this.population[0].toJSON());t.score=this.population[0].score;const e=[],n=[];let s;for(s=0;s<this.elitism;s++)n.push(this.population[s]);for(s=0;s<this.provenance;s++)e.push(o.fromJSON(this.template.toJSON()));for(s=0;s<this.popsize-this.elitism-this.provenance;s++)e.push(this.getOffspring());for(this.population=e,this.mutate(),this.population.push(...n),s=0;s<this.population.length;s++)this.population[s].score=void 0;return this.generation++,t}getOffspring(){const t=this.select(),e=this.select();return o.crossOver(t,e,this.equal)}selectMutationMethod(t){let e=this.mutation[Math.floor(Math.random()*this.mutation.length)];if(e===s.mutation.ADD_NODE&&t.nodes.length>=this.maxNodes)i.warnings&&console.warn("maxNodes exceeded!");else if(e===s.mutation.ADD_CONN&&t.connections.length>=this.maxConns)i.warnings&&console.warn("maxConns exceeded!");else{if(!(e===s.mutation.ADD_GATE&&t.gates.length>=this.maxGates))return e;i.warnings&&console.warn("maxGates exceeded!")}}mutate(){for(let t=0;t<this.population.length;t++)if(Math.random()<=this.mutationRate)for(let e=0;e<this.mutationAmount;e++){let e=this.selectMutationMethod(this.population[t]);this.population[t].mutate(e)}}async evaluate(){let t;if(this.fitnessPopulation){if(this.clear)for(t=0;t<this.population.length;t++)this.population[t].clear();await this.fitness(this.population)}else for(t=0;t<this.population.length;t++){let e=this.population[t];this.clear&&e.clear(),e.score=await this.fitness(e)}}sort(){this.population.sort((function(t,e){return e.score-t.score}))}getFittest(){return void 0===this.population[this.population.length-1].score&&this.evaluate(),this.population[0].score<this.population[1].score&&this.sort(),this.population[0]}getAverage(){void 0===this.population[this.population.length-1].score&&this.evaluate();let t=0;for(let e=0;e<this.population.length;e++)t+=this.population[e].score;return t/this.population.length}getParent(){let t;switch(this.selection){case r.POWER:{this.population[0].score<this.population[1].score&&this.sort();let t=Math.floor(Math.pow(Math.random(),this.selection.power)*this.population.length);return this.population[t]}case r.FITNESS_PROPORTIONATE:{let e=0,n=0;for(t=0;t<this.population.length;t++){let o=this.population[t].score;n=o<n?o:n,e+=o}n=Math.abs(n),e+=n*this.population.length;let o=Math.random()*e,s=0;for(t=0;t<this.population.length;t++){let e=this.population[t];if(s+=e.score+n,o<s)return e}return this.population[Math.floor(Math.random()*this.population.length)]}case r.TOURNAMENT:{if(this.selection.size>this.popsize)throw new Error("Your tournament size should be lower than the population size, please change methods.selection.TOURNAMENT.size");const e=[];for(t=0;t<this.selection.size;t++){let t=this.population[Math.floor(Math.random()*this.population.length)];e.push(t)}for(e.sort((function(t,e){return e.score-t.score})),t=0;t<this.selection.size;t++)if(Math.random()<this.selection.probability||t===this.selection.size-1)return e[t]}}}export(){const t=[];for(let e=0;e<this.population.length;e++){let n=this.population[e];t.push(n.toJSON())}return t}import(t){const e=[];for(let n=0;n<t.length;n++){let s=t[n];e.push(o.fromJSON(s))}this.population=e,this.popsize=e.length}}},362:(t,e,n)=>{var o;const s={Network:n(363),methods:n(313),Connection:n(722),architect:n(171),config:n(182),Group:n(73),Layer:n(490),Node:n(568),Neat:n(738),multi:n(607)};var i;void 0===(o=function(){return s}.apply(e,[]))||(t.exports=o),t.exports&&(t.exports=s),"object"==typeof window&&(i=window.neatml,s.ninja=function(){return window.neatml=i,s},window.neatml=s)},129:e=>{"use strict";e.exports=t},87:t=>{"use strict";t.exports=e}},o={},function t(e){var s=o[e];if(void 0!==s)return s.exports;var i=o[e]={exports:{}};return n[e](i,i.exports,t),i.exports}(362);var n,o}));